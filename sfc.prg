'SUPER FAMICOM CARTRIDGE(FLASHROM) WRITER for Pi STARTER
'BY TAKUYA MATSUBARA
ACLS
DIM SPIBUF%[3]

'KEYCODE
RIGHT = 28
LEFT  = 29
UP    = 30
DOWN  = 31
ENTER = 13
SPACE = 32
ESCAPE= &H1B

HIGH = 1
LOW = 0
KILO = 1024
MEGA = 1024*1024
ADR2M = FLOOR(2*MEGA/8) 'ADDRESS
ADR4M = FLOOR(4*MEGA/8) 'ADDRESS
ADR8M = FLOOR(8*MEGA/8) 'ADDRESS

RD  = #GPIO23 'GPIO NUMBER
ROM = #GPIO24 'GPIO NUMBER

CHIPSEL = ROM
ENABLE = RD

WE = #GPIO25 'WR
GPIOMODE RD,#GPIOMODE_OUT
GPIOMODE ROM,#GPIOMODE_OUT
GPIOMODE WE,#GPIOMODE_OUT
GPIOOUT RD,HIGH
GPIOOUT ROM,HIGH
GPIOOUT WE,HIGH
MCP23S17INIT

WHILE 1
 PRINT "SELECT ROM TYPE"
 PRINT " 1:FLASH(EN29F002T)x2 = 4M bits"
 PRINT " 2:FLASH(EN29F002T)x1 = 2M bits"
 PRINT " 3:FLASH(SST39SF040)x2= 8M bits"
 PRINT " 4:FLASH(SST39SF040)x1= 4M bits"
 INPUT "NUMBER";A$
 NUM=VAL(A$)
 IF NUM>=1 AND NUM<=4 THEN break
WEND
IF NUM==1 THEN FLASH=1:ROMBYTEMAX=ADR4M '4M
IF NUM==2 THEN FLASH=1:ROMBYTEMAX=ADR2M '2M
IF NUM==3 THEN FLASH=2:ROMBYTEMAX=ADR8M '8M
IF NUM==4 THEN FLASH=2:ROMBYTEMAX=ADR4M '4M
IF FLASH==1 THEN CHIPSIZE=ADR2M
IF FLASH==2 THEN CHIPSIZE=ADR4M

DIM BINDATA[ROMBYTEMAX] 'ROM IMAGE
FILENAME$=""

WHILE 1
 PRINT ""
 PRINT "---MENU"
 PRINT "TARGET=FLASHROM";
 PRINT "(";ROMBYTEMAX*8/MEGA;" MEGA bits)"
 PRINT " 1:READ ROM"
 PRINT " 3:ERASE FLASH MEMORY(ROMのなかみを しょうきょ)"
 PRINT " 4:WRITE IMAGE TO ROM(ROMにイメージをかきこみ)"
 PRINT " 8:DUMP IMAGE FILE(イメージファイルをみる)"
 PRINT " 0:EXIT"
 INPUT "COMMAND";CMD
 IF CMD==1 THEN GOSUB @ROMREAD
 IF CMD==3 THEN GOSUB @FLASHCHIPERASE
 IF CMD==4 THEN GOSUB @ROMWRITE
 IF CMD==8 THEN GOSUB @FILEDUMP
 IF CMD==0 THEN BREAK
WEND
CLS
END

'---
@PINTEST
  FOR I=0 TO 10
   GPIOOUT ROM,LOW
   PRINT "ROM=LOW"
   WAIT 60*3
   GPIOOUT ROM,HIGH
   PRINT "ROM=HIGH"
   WAIT 60*3
  NEXT
  FOR I=0 TO 10
   GPIOOUT RD,LOW
   PRINT "RD=LOW"
   WAIT 60*3
   GPIOOUT RD,HIGH
   PRINT "RD=HIGH"
   WAIT 60*3
  NEXT
RETURN

'---
@ROMREAD
GPIOOUT RD,HIGH
GPIOOUT ROM,HIGH
GPIOOUT WE,HIGH
MCP23S17SETDATAMODE 0 '0:INPUT/1:OUTPUT
PRINT "READ ROM 256 BYTES"
A$=""
INPUT "ADDRESS(HEX):";A$
IF A$=="" THEN A$="000000"
ROMADR=VAL("&H"+A$)
GPIOOUT CHIPSEL,LOW
USLEEP 50

WORK$ = ""
FOR I=&H00 TO &HFF
 USLEEP 50
 MCP23S17SETADR ROMADR
 USLEEP 50
 GPIOOUT ENABLE,LOW 'ENABLE
 USLEEP 50
 READDATA = MCP23S17GETDATA()
 GPIOOUT ENABLE,HIGH 'ENABLE
 X = ROMADR MOD 16
 IF X==0 THEN
  IF WORK$!="" THEN PRINT WORK$:WORK$=""
  WORK$ = HEX$(ROMADR,8)+":"+(" "*64)
 ENDIF
 WORK$ = SUBST$(WORK$,9+(X*3),2,HEX$(READDATA,2))
 IF READDATA>=&H20 AND READDATA<=&H7F THEN
  C$=CHR$(READDATA)
 ELSE
  C$="."
 ENDIF
 WORK$ = SUBST$(WORK$,9+(16*3)+X,1,C$)

 ROMADR=ROMADR+1
NEXT
IF WORK$!="" THEN PRINT WORK$:WORK$=""
GPIOOUT ENABLE,HIGH
GPIOOUT CHIPSEL,HIGH
RETURN

'---
@ROMWRITE

FILENAME$ = FILESELECT(0,".SMC")
IF FILENAME$=="" THEN RETURN

PRINT "WRITE IMAGE TO ROM"
PRINT "READ IMAGE FILE:";FILENAME$
LOAD "RAW:"+FILENAME$,BINDATA
PRINT "READ ";LEN(BINDATA);" BYTES(";LEN(BINDATA)*8;"BITS)"

GPIOOUT WE,HIGH  'DISABLE
GPIOOUT RD,HIGH  'DISABLE
GPIOOUT ROM,HIGH  'DISABLE

MCP23S17SETDATAMODE 1 '0:INPUT/1:OUTPUT

IF INPUTYN()==ASC("N") THEN RETURN

ERRFLAG=0
STARTCNT=MAINCNT

WORK$ = ""
FOR ROMADR=0 TO LEN(BINDATA)-1
 IF ROMADR>=ROMBYTEMAX THEN BREAK

 WRITEDATA = BINDATA[ROMADR]
 FLASHWRITEBYTE ROMADR,WRITEDATA

 X = ROMADR MOD 16
 IF X==0 THEN
  IF WORK$!="" THEN PRINT WORK$:WORK$=""
  WORK$ = HEX$(ROMADR,8)+":"+(" "*64)
  IF (ROMADR AND &HFF)==0 THEN PRINT FLOOR(ROMADR*100/LEN(BINDATA));"%"
 ENDIF
 WORK$ = SUBST$(WORK$,9+(X*3),2,HEX$(WRITEDATA,2))
 IF ERRFLAG THEN RETURN
NEXT
IF WORK$!="" THEN PRINT WORK$:WORK$=""
MCP23S17SETDATAMODE 0 '0:INPUT/1:OUTPUT

IF ERRFLAG THEN RETURN

WORKTIME=FLOOR((MAINCNT-STARTCNT)/(60*60))
PRINT "COMPLETE"
PRINT "RUNNING TIME:";WORKTIME;" MINUTE"
RETURN

'---
@FLASHCHIPERASE

PRINT "FLASH MEMORY CHIP ERASE"

IF INPUTYN()==ASC("N") THEN RETURN

FOR ROMADR=0 TO ROMBYTEMAX-1 STEP CHIPSIZE
 PRINT "ADDRESS ";HEX$(ROMADR);" - ";HEX$(ROMADR+CHIPSIZE-1)
 FLASHCHIPERASESUB ROMADR
NEXT
RETURN

'---
DEF FLASHWRITEBYTE ROMADR,WRITEDATA
 IF WRITEDATA==&HFF THEN RETURN
 CHIPADR=FLOOR(ROMADR/CHIPSIZE)*CHIPSIZE '
 GPIOOUT RD,HIGH  'DISABLE
 GPIOOUT WE,HIGH  'DISABLE
 GPIOOUT ROM,HIGH 'DISABLE
 CLKWAIT
 GPIOOUT CHIPSEL,LOW 'ENABLE
 IF FLASH==1 THEN 'EN29F002T
  SETADR_DATA CHIPADR+&H555,&HAA 'CYCLE1
  SETWECLK
  SETADR_DATA CHIPADR+&HAAA,&H55 'CYCLE2
  SETWECLK
  SETADR_DATA CHIPADR+&H555,&HA0 'CYCLE3
  SETWECLK
  SETADR_DATA ROMADR,WRITEDATA   'CYCLE4
  SETWECLK
 ELSE 'SST39SF040
  SETADR_DATA CHIPADR+&H5555,&HAA 'CYCLE1
  SETWECLK
  SETADR_DATA CHIPADR+&H2AAA,&H55 'CYCLE2
  SETWECLK
  SETADR_DATA CHIPADR+&H5555,&HA0 'CYCLE3
  SETWECLK
  SETADR_DATA ROMADR,WRITEDATA   'CYCLE4
  SETWECLK
 ENDIF
 GPIOOUT CHIPSEL,HIGH  'DISABLE
 CLKWAIT
END

'---EN29F002T
DEF FLASHCHIPERASESUB ROMADR
CHIPADR = FLOOR(ROMADR/CHIPSIZE)*CHIPSIZE '
MCP23S17SETDATAMODE 1 '0:INPUT/1:OUTPUT

IF FLASH==1 THEN 'EN29F002T
 GPIOOUT ENABLE,LOW 'ENABLE
 GPIOOUT WE,HIGH    'DISABLE
 GPIOOUT RD,HIGH    'DISABLE
 CLKWAIT
 SETADR_DATA CHIPADR+&H555,&HAA 'CYCLE1
 GPIOOUT CHIPSEL,LOW 'ENABLE
 CLKWAIT
 GPIOOUT ENABLE,HIGH
 CLKWAIT
 SETWECLK 'WE=LOW-->HIGH
 GPIOOUT CHIPSEL,HIGH
 SETADR_DATA CHIPADR+&HAAA,&H55 'CYCLE2
 GPIOOUT CHIPSEL,LOW
 SETWECLK 'WE=LOW-->HIGH
 SETADR_DATA CHIPADR+&H555,&H80 'CYCLE3
 SETWECLK 'WE=LOW-->HIGH
 SETADR_DATA CHIPADR+&H555,&HAA 'CYCLE4
 SETWECLK 'WE=LOW-->HIGH
 SETADR_DATA CHIPADR+&HAAA,&H55 'CYCLE5
 SETWECLK 'WE=LOW-->HIGH
 SETADR_DATA CHIPADR+&H555,&H10 'CYCLE6
 SETWECLK 'WE=LOW-->HIGH
ELSE
 GPIOOUT ENABLE,LOW 'ENABLE
 GPIOOUT WE,HIGH    'DISABLE
 GPIOOUT RD,HIGH    'DISABLE
 CLKWAIT
 SETADR_DATA CHIPADR+&H5555,&HAA 'CYCLE1
 GPIOOUT CHIPSEL,LOW 'ENABLE
 CLKWAIT
 GPIOOUT ENABLE,HIGH
 CLKWAIT
 SETWECLK 'WE=LOW-->HIGH
 GPIOOUT CHIPSEL,HIGH
 SETADR_DATA CHIPADR+&H2AAA,&H55 'CYCLE2
 GPIOOUT CHIPSEL,LOW
 SETWECLK 'WE=LOW-->HIGH
 SETADR_DATA CHIPADR+&H5555,&H80 'CYCLE3
 SETWECLK 'WE=LOW-->HIGH
 SETADR_DATA CHIPADR+&H5555,&HAA 'CYCLE4
 SETWECLK 'WE=LOW-->HIGH
 SETADR_DATA CHIPADR+&H2AAA,&H55 'CYCLE5
 SETWECLK 'WE=LOW-->HIGH
 SETADR_DATA CHIPADR+&H5555,&H10 'CYCLE6
 SETWECLK 'WE=LOW-->HIGH
ENDIF

FOR I=1 TO 30
 PRINT " ";I;"/30"
 WAIT 60
NEXT
GPIOOUT CHIPSEL,HIGH  'DISABLE
GPIOOUT ENABLE,HIGH
MCP23S17SETDATAMODE 0 '0:INPUT/1:OUTPUT
END

'---
DEF SETADR_DATA ROMADR,WRITEDATA
 MCP23S17SETADR ROMADR
 MCP23S17SETDATA WRITEDATA
END

'---
DEF SETWECLK
 USLEEP 10
 GPIOOUT WE,LOW  'ENABLE
 USLEEP 30
 GPIOOUT WE,HIGH  'DISABLE
 USLEEP 20
END

'---
DEF MCP23S17GETDATA()
 MCP23S17RECV 1,&H13 ' CHIP1:B
 RETURN(SPIBUF%[2])
END

'---
DEF MCP23S17SETDATA DAT
 MCP23S17SEND 1,&H13,DAT 'CHIP1 GPIOB
END

'---
DEF MCP23S17SETADR WORKADR
 'LOROM
 ADRL = WORKADR AND &H007FFF 'A0 - A14
 ADRH = (WORKADR AND &H7F8000)<<1 'A15 - A22
 WORKADR = ADRH+ADRL
 MCP23S17SEND 0,&H12,(WORKADR AND &HFF)       'A00-07 CHIP0:A
 MCP23S17SEND 0,&H13,((WORKADR>>8) AND &HFF)  'A08-15 CHIP0:B
 MCP23S17SEND 1,&H12,((WORKADR>>16) AND &HFF) 'A16-23 CHIP1:A
END

'---
DEF MCP23S17SETADR16 WORKADR
 'LOROM
 ADRL = WORKADR AND &H007FFF 'A0 - A14
 ADRH = (WORKADR AND &H7F8000)<<1 'A15 - A22
 WORKADR = ADRH+ADRL
 MCP23S17SEND 0,&H12,(WORKADR AND &HFF)       'A00-07 CHIP0:A
 MCP23S17SEND 0,&H13,((WORKADR>>8) AND &HFF)  'A08-15 CHIP0:B
END

'---
DEF MCP23S17SETDATAMODE D '0:INPUT/1:OUTPUT
 IF D THEN
  MCP23S17SEND 1,&H01,&H00 'CHIP1 IODIRB OUTPUT
 ELSE
  MCP23S17SEND 1,&H01,&HFF 'CHIP1 IODIRB INPUT
 ENDIF
END

'---
DEF MCP23S17INIT
' F=600000 'SPI クロック(HZ)
' F=800000 'SPI クロック(HZ)
 F=400000 'SPI クロック(HZ)
' T=0 'タイミング CPOL=0,CPHA=0
 T=1 'タイミング CPOL=0,CPHA=1
' T=2 'タイミング CPOL=1,CPHA=0
' T=3 'タイミング CPOL=1,CPHA=1

 SPISTART F,T
 WAIT 15

 MCP23S17SEND 0,&H0A,&H28  'IOCON
 '  BANK/MIRROR/SEQOP/DISSLW/HAEN/ODR/INTPOL/0

 MCP23S17SEND 0,&H00,&H00 'CHIP0 IODIRA OUTPUT
 MCP23S17SEND 0,&H01,&H00 'CHIP0 IODIRB OUTPUT

 MCP23S17SEND 1,&H00,&H00 'CHIP1 IODIRA OUTPUT
 MCP23S17SEND 1,&H01,&HFF 'CHIP1 IODIRB INPUT

 MCP23S17SEND 0,&H12,&H00 'CHIP0 GPIOA
 MCP23S17SEND 0,&H13,&H00 'CHIP0 GPIOB

 MCP23S17SEND 1,&H12,&H00 'CHIP1 GPIOA
 MCP23S17SEND 1,&H13,&H00 'CHIP1 GPIOB
END

'---
DEF MCP23S17SEND CHIP,ADDRESS, DAT
 SPIBUF%[0]=&H40+(CHIP<<1)
 SPIBUF%[1]=ADDRESS
 SPIBUF%[2]=DAT
 SPISEND SPIBUF%,3
 CLKWAIT
END

'---
DEF MCP23S17RECV CHIP,ADDRESS
 SPIBUF%[0]=&H40+(CHIP<<1)+1
 SPIBUF%[1]=ADDRESS
 SPIBUF%[2]=0
 SPISENDRECV SPIBUF%,3
 CLKWAIT
END

'---
DEF CLKWAIT
' USLEEP 50
 USLEEP 20
END

'---
@FILEDUMP
FILENAME$ = FILESELECT(0,".SMC")
IF FILENAME$=="" THEN RETURN

PRINT "IMAGE FILE DUMP"
PRINT "FILE NAME:";FILENAME$

LOAD "RAW:"+FILENAME$,BINDATA
PRINT "READ ";LEN(BINDATA);" BYTES(";LEN(BINDATA)*8;"BITS)"
A$=""
INPUT "ADDRESS(HEX):";A$
IF A$=="" THEN A$="000000"
ROMADR=VAL("&H"+A$)
WORK$=""
FOR I=0 TO &H1FF
 IF ROMADR>=LEN(BINDATA) THEN BREAK
 X = ROMADR MOD 16
 WRITEDATA = BINDATA[ROMADR]
 IF X==0 THEN
  IF WORK$!="" THEN PRINT WORK$:WORK$=""
  WORK$ = HEX$(ROMADR,8)+":"+(" "*64)
 ENDIF
 WORK$ = SUBST$(WORK$,9+(X*3),2,HEX$(WRITEDATA,2))
 IF WRITEDATA>=&H20 AND WRITEDATA<=&H7F THEN
  C$=CHR$(WRITEDATA)
 ELSE
  C$="."
 ENDIF
 WORK$ = SUBST$(WORK$,9+(16*3)+X,1,C$)
 ROMADR=ROMADR+1
NEXT
IF WORK$!="" THEN PRINT WORK$:WORK$=""

'ROM INFO(LOROM)
'BASEADR=&H7000
'A$=""
'FOR I=0 TO 20
' A$=A$+CHR$(BINDATA[BASEADR+&HFC0+I])
'NEXT
'PRINT "GAME TITLE:";A$
'PRINT "ROM MAKEUP BYTE:";HEXBYTE(&HFD5)
'PRINT "ROM TYPE:";HEXBYTE(&HFD6)
'PRINT "ROM SIZE:";HEX$(&H400 << BINDATA[BASEADR+&HFD7]);"BYTES"
'PRINT "SRAM SIZE:";HEXBYTE(&HFD8)
'PRINT "CREATOR LICENSE ID CODE:";HEXBYTE(&HFD9)
'PRINT "VERSION:";HEXBYTE(&HFDB)
'PRINT "CHECKSUM:";HEXBYTE(&HFDC)
'PRINT "CHECKSUM:";HEXBYTE(&HFDE)
'PRINT "COPROCESSOR ENABLE:";HEXBYTE(&HFE5);HEXBYTE(&HFE4)
'PRINT "NATIVE VECTOR.BRK:";HEXBYTE(&HFE7);HEXBYTE(&HFE6)
'PRINT "NATIVE VECTOR.ABORT:";HEXBYTE(&HFE9);HEXBYTE(&HFE8)
'PRINT "NATIVE VECTOR.NMI:";HEXBYTE(&HFEB);HEXBYTE(&HFEA)
'PRINT "NATIVE VECTOR.IRQ:";HEXBYTE(&HFEF);HEXBYTE(&HFEE)
RETURN

'---
DEF HEXBYTE(ADR)
 RETURN(HEX$(BINDATA[BASEADR+ADR],2))
END

'---
DEF FILESELECT(DIRFLAG,FILTER$)

DIM NAME$[0]
DIM NAME2$[0]
COLOR #WHITE,0
CLS

FILTER$=UCASE(FILTER$)

FP=48
FH=20

PATH$=CHDIR()
SELPATH$=PATH$
OFX=0
OFY=0

LOCATE 1,FH+4
PRINT "[UP][DOWN]:カ-ソルいどう / [SPACE]:けってい / [ESC]:CANCEL"

WHILE 1
 COLOR #BLACK,#BLUE
 FOR I=0 TO FH+1+2
  LOCATE OFX,OFY+I
  PRINT " "*(FP+2)
 NEXT
 COLOR #WHITE,0
 FOR I=0 TO FH-1
  LOCATE OFX+1,OFY+I+1+2
  PRINT " "*FP
 NEXT
 
 LOCATE OFX+1,OFY+1
 PRINT "DIR:";SELPATH$

 IF FILTER$!="" THEN
  LOCATE OFX+38,OFY+1
  PRINT "FILTER:";FILTER$
 ENDIF
 WHILE LEN(NAME2$)
  R$=POP(NAME2$)
 WEND
 FILES SELPATH$,NAME$
 FOR I=0 TO LEN(NAME$)-1
  T$=NAME$[I]
  KAK$=RIGHT$(T$,4)
  IF UCASE(KAK$)==".PRG" THEN CONTINUE
  IF MID$(T$,1,1)=="@" THEN CONTINUE
  IF DIRFLAG==0 THEN
   IF LEFT$(T$,1)!="+" THEN
    IF FILTER$!="" AND INSTR(UCASE(T$),FILTER$)<0 THEN CONTINUE
   ENDIF
  ELSE
   IF LEFT$(T$,1)!="+" THEN CONTINUE
  ENDIF
  PUSH NAME2$,T$
 NEXT
 UNSHIFT NAME2$,"+.."

 IF DIRFLAG THEN
  PUSH NAME2$,"["+SELPATH$+"にけってい]"
  IDX=LEN(NAME2$)-1
 ELSE
  IDX=0
 ENDIF

 IDXOFS=0
 WHILE 1
  FOR I=0 TO LEN(NAME2$)-1
   X=OFX+1
   Y=(I-IDXOFS)
   IF Y<0 THEN CONTINUE
   IF Y>=FH THEN BREAK
   Y=Y+OFY+1+2
   LOCATE X,Y
   T$=" "*FP
   T$=SUBST$(T$,0,LEN(NAME2$[I]),NAME2$[I])
   IF IDX==I THEN COLOR 0,#WHITE ELSE COLOR #WHITE,0
   PRINT T$;
  NEXT
  COLOR #WHITE,0

  BT=KEYWAIT()
  IF BT==SPACE THEN BREAK
  IF BT==ENTER THEN BREAK
  IF BT==UP    THEN DEC IDX
  IF BT==DOWN  THEN INC IDX
  IF BT==ESCAPE THEN IDX=-1:BREAK

  IDX=FIXNUM(IDX,0,LEN(NAME2$)-1)

  WHILE IDXOFS>IDX
   DEC IDXOFS
  WEND
  WHILE (IDXOFS+FH-1)<IDX
   INC IDXOFS
  WEND
 WEND
 LOCATE 1,FH+4
 PRINT " "*80

 IF IDX<0 THEN SELPATH$="":BREAK

 NB$=MID$(NAME2$[IDX],0,1)
 NA$=MID$(NAME2$[IDX],1,999)
 IF DIRFLAG==0 THEN
  IF NB$!="+" THEN
   IF RIGHT$(SELPATH$,1)!="/" THEN SELPATH$=SELPATH$+"/"
   RETURN (SELPATH$+NA$)
  ENDIF
 ELSE
  IF IDX==LEN(NAME2$)-1 THEN BREAK
 ENDIF

 IF NA$==".." THEN
  TMP=1
  WHILE 1
   IF LEFT$(RIGHT$(SELPATH$,TMP),1)=="/" THEN BREAK
   INC TMP
  WEND
  SELPATH$=LEFT$(SELPATH$,LEN(SELPATH$)-TMP)
  IF LEFT$(SELPATH$,1)!="/" THEN SELPATH$="/"+SELPATH$
 ELSE
  IF RIGHT$(SELPATH$,1)!="/" THEN SELPATH$=SELPATH$+"/"
  SELPATH$=SELPATH$+NA$
 ENDIF
WEND
RETURN SELPATH$
END

'---
DEF LCASE(TMP$)
 FOR TMPI=0 TO LEN(TMP$)-1
  TMPC=ASC(MID$(TMP$,TMPI,1))
  IF TMPC>=&H41 AND TMPC<=&H5A THEN
   TMP$=SUBST$(TMP$,TMPI,1,CHR$(TMPC+&H20))
  ENDIF
 NEXT
 RETURN TMP$
END

'---
DEF UCASE(TMP$)
 FOR TMPI=0 TO LEN(TMP$)-1
  TMPC=ASC(MID$(TMP$,TMPI,1))
  IF TMPC>=&H61 AND TMPC<=&H7A THEN
   TMP$=SUBST$(TMP$,TMPI,1,CHR$(TMPC-&H20))
  ENDIF
 NEXT
 RETURN TMP$
END

'---
DEF KEYWAIT()
 BT=0
 WHILE BT==0
  VSYNC 1
  NOWKEY$=INKEY$()
  IF NOWKEY$ != "" THEN BT=ASC(NOWKEY$)
 WEND
 WHILE 1
  VSYNC 2
  IF INKEY$=="" THEN BREAK 'KEY BUFF CLEAR
 WEND
 IF BT>=&H60 AND BT<=&H7A THEN BT=BT-&H20 'UCASE
 RETURN BT
END

'---
DEF SWOFFWAIT
 WHILE 1
  VSYNC 1
  IF INKEY$=="" THEN BREAK
 WEND
END

'---
DEF INPUTYN()
 PRINT
 COLOR #BLACK,#WHITE
 PRINT " よろしいですか? [Y]/[N] ";
 COLOR #WHITE,0
 WHILE 1
  YN=KEYWAIT()
  IF YN==ASC("Y") THEN PRINT " YES":BREAK
  IF YN==ASC("N") THEN PRINT " NO":BREAK
 WEND
 WAIT 30
 RETURN YN
END

'---
DEF FIXNUM(NUM,MINNUM,MAXNUM)
 IF NUM<MINNUM THEN NUM=MINNUM
 IF NUM>MAXNUM THEN NUM=MAXNUM
 RETURN NUM
END

